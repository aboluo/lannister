<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Session.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Lannister server</a> &gt; <a href="index.source.html" class="el_package">net.anyflow.lannister.session</a> &gt; <span class="el_source">Session.java</span></div><h1>Session.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 The Lannister Project
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.anyflow.lannister.session;

import java.io.IOException;
import java.util.Date;
import java.util.concurrent.locks.Lock;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;

import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelId;
import io.netty.handler.codec.mqtt.MqttMessage;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import io.netty.util.concurrent.GlobalEventExecutor;
import net.anyflow.lannister.Literals;
import net.anyflow.lannister.cluster.ClusterDataDisposer;
import net.anyflow.lannister.cluster.ClusterDataFactory;
import net.anyflow.lannister.message.Message;
import net.anyflow.lannister.message.OutboundMessageStatus;
import net.anyflow.lannister.plugin.DisconnectEventArgs;
import net.anyflow.lannister.plugin.DisconnectEventListener;
import net.anyflow.lannister.plugin.Plugins;
import net.anyflow.lannister.serialization.ChannelIdSerializer;
import net.anyflow.lannister.serialization.SerializableFactory;
import net.anyflow.lannister.topic.Topic;
import net.anyflow.lannister.topic.TopicMatcher;
import net.anyflow.lannister.topic.TopicSubscriber;
import net.anyflow.lannister.topic.TopicSubscription;

public class Session implements com.hazelcast.nio.serialization.IdentifiedDataSerializable {

<span class="fc" id="L55">	private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(Session.class);</span>

<span class="fc" id="L57">	public static final Sessions NEXUS = new Sessions();</span>
	public static final int ID = 4;

	@JsonProperty
	private String clientId;
	@JsonProperty
	private String ip;
	@JsonProperty
	private int port;
	@JsonProperty
	private boolean isConnected;
	@JsonProperty
	private int currentMessageId;
	@JsonProperty
	private Message will;
	@JsonProperty
	private boolean cleanSession;
	@JsonProperty
	private int keepAliveSeconds;
	@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = Literals.DATE_DEFAULT_FORMAT, timezone = Literals.DATE_DEFAULT_TIMEZONE)
	@JsonProperty
	private Date createTime;
	@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = Literals.DATE_DEFAULT_FORMAT, timezone = Literals.DATE_DEFAULT_TIMEZONE)
	@JsonProperty
	private Date lastIncomingTime;

	private MessageSender messageSender;

	private Lock disposeLock;

<span class="nc" id="L87">	public Session() { // just for serialization</span>
<span class="nc" id="L88">	}</span>

<span class="fc" id="L90">	public Session(String clientId, String ip, int port, int keepAliveSeconds, boolean cleanSession, Message will) {</span>
<span class="fc" id="L91">		this.clientId = clientId;</span>
<span class="fc" id="L92">		this.ip = ip;</span>
<span class="fc" id="L93">		this.port = port;</span>
<span class="fc" id="L94">		this.isConnected = true;</span>
<span class="fc" id="L95">		this.createTime = new Date();</span>
<span class="fc" id="L96">		this.currentMessageId = 0;</span>
<span class="fc" id="L97">		this.keepAliveSeconds = keepAliveSeconds;</span>
<span class="fc" id="L98">		this.lastIncomingTime = new Date();</span>
<span class="fc" id="L99">		this.cleanSession = cleanSession;</span>
<span class="fc" id="L100">		this.will = will; // [MQTT-3.1.2-9]</span>
<span class="fc" id="L101">		this.disposeLock = ClusterDataFactory.INSTANCE.createLock(&quot;Session_disposeLock_&quot; + clientId);</span>

<span class="fc" id="L103">		this.messageSender = new MessageSender(this);</span>
<span class="fc" id="L104">	}</span>

	@JsonSerialize(using = ChannelIdSerializer.class)
	@JsonProperty
	public ChannelId channelId() {
<span class="fc" id="L109">		ChannelHandlerContext ctx = NEXUS.channelHandlerContext(clientId);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">		if (ctx == null) { return null; }</span>

<span class="fc" id="L112">		return ctx.channel().id();</span>
	}

	public boolean isConnected(boolean checkOwnership) {
<span class="fc bfc" id="L116" title="All 2 branches covered.">		if (!isConnected) { return false; }</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		if (!checkOwnership) { return isConnected; }</span>

<span class="fc" id="L119">		ChannelHandlerContext ctx = NEXUS.channelHandlerContext(clientId);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		if (ctx == null) { return false; }</span>

<span class="fc" id="L122">		return ctx.channel().isActive();</span>
	}

	public void setConnected(boolean isConnected) {
<span class="fc" id="L126">		this.isConnected = isConnected;</span>

<span class="fc" id="L128">		Session.NEXUS.persist(this);</span>
<span class="fc" id="L129">	}</span>

	public String clientId() {
<span class="fc" id="L132">		return clientId;</span>
	}

	public Message will() {
<span class="fc" id="L136">		return will;</span>
	}

	public void will(Message will) {
<span class="fc" id="L140">		this.will = will;</span>

<span class="fc" id="L142">		Session.NEXUS.persist(this);</span>
<span class="fc" id="L143">	}</span>

	public boolean cleanSession() {
<span class="fc" id="L146">		return cleanSession;</span>
	}

	public boolean isExpired() {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">		if (keepAliveSeconds == 0) { return false; }</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">		return (new Date().getTime() - lastIncomingTime.getTime()) &gt; keepAliveSeconds * 1.5 * 1000;</span>
	}

	public void setLastIncomingTime(Date lastIncomingTime) {
<span class="fc" id="L156">		this.lastIncomingTime = lastIncomingTime;</span>

<span class="fc" id="L158">		Session.NEXUS.persist(this);</span>
<span class="fc" id="L159">	}</span>

	public TopicSubscription matches(String topicName) {
<span class="fc" id="L162">		return TopicSubscription.NEXUS.topicFiltersOf(clientId).stream()</span>
<span class="fc" id="L163">				.filter(topicFilter -&gt; TopicMatcher.match(topicFilter, topicName))</span>
<span class="fc" id="L164">				.map(topicFilter -&gt; TopicSubscription.NEXUS.getBy(topicFilter, clientId))</span>
<span class="fc" id="L165">				.max((p1, p2) -&gt; p1.qos().compareTo(p2.qos())).orElse(null); // [MQTT-3.3.5-1]</span>
	}

	public void send(MqttMessage message, GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; completeListener) {
<span class="fc" id="L169">		messageSender.send(message, completeListener);</span>
<span class="fc" id="L170">	}</span>

	protected void sendPublish(Topic topic, Message message) {
<span class="fc" id="L173">		messageSender.sendPublish(topic, message);</span>
<span class="fc" id="L174">	}</span>

	public void completeRemainedMessages() {
<span class="fc" id="L177">		messageSender.completeRemainedMessages();</span>
<span class="fc" id="L178">	}</span>

	public int nextMessageId() {
<span class="fc" id="L181">		currentMessageId = currentMessageId + 1;</span>

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		if (currentMessageId &gt; Message.MAX_MESSAGE_ID_NUM) {</span>
<span class="nc" id="L184">			currentMessageId = Message.MIN_MESSAGE_ID_NUM;</span>
		}

<span class="fc" id="L187">		Session.NEXUS.persist(this);</span>

<span class="fc" id="L189">		return currentMessageId;</span>
	}

	public void dispose(boolean sendWill) {
<span class="fc" id="L193">		setConnected(false);</span>

<span class="fc bfc" id="L195" title="All 4 branches covered.">		if (sendWill &amp;&amp; will != null) { // [MQTT-3.1.2-12]</span>
<span class="fc" id="L196">			Topic topic = Topic.NEXUS.prepare(will);</span>
<span class="fc" id="L197">			topic.publish(will);</span>

<span class="fc" id="L199">			will(null); // [MQTT-3.1.2-10]</span>
		}

<span class="fc" id="L202">		ChannelId channelId = null;</span>
<span class="fc" id="L203">		ChannelHandlerContext ctx = NEXUS.channelHandlerContext(clientId);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">		if (ctx != null) {</span>
<span class="fc" id="L205">			ctx.channel().disconnect().addListener(ChannelFutureListener.CLOSE);</span>
<span class="fc" id="L206">			channelId = ctx.channel().id();</span>
		}

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		logger.debug(&quot;Session disposed [clientId={}, channelId={}]&quot;, clientId, ctx == null ? &quot;null&quot; : channelId);</span>

<span class="pc bpc" id="L211" title="1 of 2 branches missed.">		EventExecutor executor = ctx != null ? ctx.channel().eventLoop() : GlobalEventExecutor.INSTANCE;</span>
<span class="fc" id="L212">		executor.execute(</span>
<span class="fc" id="L213">				() -&gt; Plugins.INSTANCE.get(DisconnectEventListener.class).disconnected(new DisconnectEventArgs() {</span>
					@Override
					public String clientId() {
<span class="fc" id="L216">						return clientId;</span>
					}

					@Override
					public Boolean cleanSession() {
<span class="fc" id="L221">						return cleanSession;</span>
					}

					@Override
					public Boolean byDisconnectMessage() {
<span class="fc bfc" id="L226" title="All 2 branches covered.">						return !sendWill;</span>
					}
				}));

		// TODO WHY =&gt; Current thread is not owner of the lock! -&gt; &lt;not-locked&gt;
		// disposeLock.lock();
		// try {
<span class="fc bfc" id="L233" title="All 2 branches covered.">		if (cleanSession) {</span>
<span class="fc" id="L234">			TopicSubscriber.NEXUS.removeByClientId(clientId);</span>
<span class="fc" id="L235">			TopicSubscription.NEXUS.removeByClientId(clientId);</span>
<span class="fc" id="L236">			OutboundMessageStatus.NEXUS.removeByClientId(clientId);</span>
		}

<span class="fc" id="L239">		NEXUS.remove(this);</span>
		// }
		// finally {
		// disposeLock.unlock();
		// }

<span class="fc" id="L245">		ClusterDataDisposer.INSTANCE.disposeLock(disposeLock);</span>

<span class="fc" id="L247">	}</span>

	@JsonIgnore
	@Override
	public int getFactoryId() {
<span class="nc" id="L252">		return SerializableFactory.ID;</span>
	}

	@JsonIgnore
	@Override
	public int getId() {
<span class="nc" id="L258">		return ID;</span>
	}

	@Override
	public void writeData(ObjectDataOutput out) throws IOException {
<span class="nc" id="L263">		out.writeUTF(clientId);</span>
<span class="nc" id="L264">		out.writeUTF(ip);</span>
<span class="nc" id="L265">		out.writeInt(port);</span>
<span class="nc" id="L266">		out.writeBoolean(isConnected);</span>
<span class="nc" id="L267">		out.writeInt(currentMessageId);</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">		out.writeBoolean(will != null);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">		if (will != null) {</span>
<span class="nc" id="L271">			will.writeData(out);</span>
		}

<span class="nc" id="L274">		out.writeBoolean(cleanSession);</span>
<span class="nc" id="L275">		out.writeInt(keepAliveSeconds);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">		out.writeLong(createTime != null ? createTime.getTime() : Long.MIN_VALUE);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">		out.writeLong(lastIncomingTime != null ? lastIncomingTime.getTime() : Long.MIN_VALUE);</span>
<span class="nc" id="L278">	}</span>

	@Override
	public void readData(ObjectDataInput in) throws IOException {
<span class="nc" id="L282">		clientId = in.readUTF();</span>
<span class="nc" id="L283">		ip = in.readUTF();</span>
<span class="nc" id="L284">		port = in.readInt();</span>
<span class="nc" id="L285">		isConnected = in.readBoolean();</span>
<span class="nc" id="L286">		currentMessageId = in.readInt();</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">		if (in.readBoolean()) {</span>
<span class="nc" id="L289">			will = new Message(in);</span>
		}

<span class="nc" id="L292">		cleanSession = in.readBoolean();</span>
<span class="nc" id="L293">		keepAliveSeconds = in.readInt();</span>

<span class="nc" id="L295">		long rawLong = in.readLong();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">		createTime = rawLong != Long.MIN_VALUE ? new Date(rawLong) : null;</span>

<span class="nc" id="L298">		rawLong = in.readLong();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">		lastIncomingTime = rawLong != Long.MIN_VALUE ? new Date(rawLong) : null;</span>

<span class="nc" id="L301">		disposeLock = ClusterDataFactory.INSTANCE.createLock(&quot;Session_disposeLock_&quot; + clientId);</span>
<span class="nc" id="L302">		messageSender = new MessageSender(this);</span>
<span class="nc" id="L303">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>