<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConnectReceiver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Lannister server</a> &gt; <a href="index.source.html" class="el_package">net.anyflow.lannister.packetreceiver</a> &gt; <span class="el_source">ConnectReceiver.java</span></div><h1>ConnectReceiver.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 The Lannister Project
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.anyflow.lannister.packetreceiver;

import java.net.InetSocketAddress;

import com.google.common.base.Strings;

import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.mqtt.MqttConnAckMessage;
import io.netty.handler.codec.mqtt.MqttConnectMessage;
import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
import io.netty.handler.codec.mqtt.MqttQoS;
import io.netty.util.CharsetUtil;
import net.anyflow.lannister.AbnormalDisconnectEventArgs;
import net.anyflow.lannister.Settings;
import net.anyflow.lannister.cluster.ClusterDataFactory;
import net.anyflow.lannister.message.Message;
import net.anyflow.lannister.plugin.Authenticator;
import net.anyflow.lannister.plugin.Authorizer;
import net.anyflow.lannister.plugin.ConnectEventArgs;
import net.anyflow.lannister.plugin.ConnectEventListener;
import net.anyflow.lannister.plugin.DisconnectEventListener;
import net.anyflow.lannister.plugin.IMessage;
import net.anyflow.lannister.plugin.Plugins;
import net.anyflow.lannister.plugin.ServiceChecker;
import net.anyflow.lannister.session.Session;
import net.anyflow.lannister.topic.Topic;

<span class="pc bpc" id="L47" title="1 of 2 branches missed.">@Sharable</span>
<span class="fc" id="L48">public class ConnectReceiver extends SimpleChannelInboundHandler&lt;MqttConnectMessage&gt; {</span>
<span class="fc" id="L49">	private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(ConnectReceiver.class);</span>
<span class="fc" id="L50">	public static final ConnectReceiver INSTANCE = new ConnectReceiver();</span>

	@Override
	protected void channelRead0(ChannelHandlerContext ctx, MqttConnectMessage msg) throws Exception {
<span class="fc" id="L54">		logger.debug(&quot;packet incoming [message={}]&quot;, msg.toString());</span>

<span class="fc" id="L56">		Session session = Session.NEXUS.get(ctx.channel().id());</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">		if (session != null) {</span>
<span class="nc" id="L58">			session.dispose(true); // [MQTT-3.1.0-2]</span>
<span class="nc" id="L59">			return;</span>
		}

<span class="fc" id="L62">		boolean cleanSession = msg.variableHeader().isCleanSession();</span>
<span class="fc" id="L63">		String clientId = msg.payload().clientIdentifier();</span>

<span class="fc bfc" id="L65" title="All 2 branches covered.">		if (Strings.isNullOrEmpty(clientId)) {</span>
<span class="fc" id="L66">			clientId = generateClientId(ctx, cleanSession);</span>

<span class="fc bfc" id="L68" title="All 2 branches covered.">			if (clientId == null) { return; }</span>
		}

<span class="fc bfc" id="L71" title="All 2 branches covered.">		if (!filterPlugins(ctx, msg)) { return; }</span>

<span class="fc" id="L73">		session = Session.NEXUS.get(clientId); // [MQTT-3.1.2-4]</span>
<span class="pc bpc" id="L74" title="1 of 4 branches missed.">		boolean sessionPresent = !cleanSession &amp;&amp; session != null; // [MQTT-3.2.2-1],[MQTT-3.2.2-2],[MQTT-3.2.2-3]</span>

<span class="fc bfc" id="L76" title="All 2 branches covered.">		String clientIp = ctx.channel().remoteAddress() instanceof InetSocketAddress</span>
<span class="fc" id="L77">				? ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress() : &quot;0.0.0.0&quot;;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">		int clientPort = ctx.channel().remoteAddress() instanceof InetSocketAddress</span>
<span class="fc" id="L79">				? ((InetSocketAddress) ctx.channel().remoteAddress()).getPort() : -1;</span>

<span class="fc bfc" id="L81" title="All 2 branches covered.">		if (cleanSession) {</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">			if (session != null) {</span>
<span class="fc" id="L83">				session.dispose(false); // [MQTT-3.1.4-2]</span>
			}
<span class="fc" id="L85">			session = newSession(msg, cleanSession, clientId, clientIp, clientPort); // [MQTT-3.1.2-6]</span>
		}
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">		else if (session == null) { // [MQTT-3.1.2-4]</span>
<span class="fc" id="L88">			session = newSession(msg, cleanSession, clientId, clientIp, clientPort);</span>
		}

<span class="fc" id="L91">		Session.NEXUS.put(session, ctx);</span>

<span class="fc" id="L93">		processRetainedWill(session);</span>

<span class="fc" id="L95">		final Session sessionFinal = session;</span>
<span class="fc" id="L96">		final MqttConnAckMessage acceptMsg = MqttMessageFactory.connack(MqttConnectReturnCode.CONNECTION_ACCEPTED,</span>
				sessionPresent); // [MQTT-3.1.4-4]
<span class="fc" id="L98">		final String log = acceptMsg.toString();</span>

<span class="fc" id="L100">		session.send(acceptMsg, f -&gt; { // [MQTT-3.2.0-1]</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">			if (!f.isSuccess()) {</span>
<span class="nc" id="L102">				logger.error(&quot;packet outgoing failed [{}] {}&quot;, log, f.cause());</span>
<span class="nc" id="L103">				return;</span>
			}

<span class="fc" id="L106">			ctx.channel().eventLoop().execute(</span>
<span class="fc" id="L107">					() -&gt; Plugins.INSTANCE.get(ConnectEventListener.class).connectHandled(new ConnectEventArgs() {</span>
						@Override
						public String clientId() {
<span class="fc" id="L110">							return sessionFinal.clientId();</span>
						}

						@Override
						public IMessage will() {
<span class="fc" id="L115">							return sessionFinal.will();</span>
						}

						@Override
						public Boolean cleanSession() {
<span class="fc" id="L120">							return sessionFinal.cleanSession();</span>
						}

						@Override
						public MqttConnectReturnCode returnCode() {
<span class="fc" id="L125">							return MqttConnectReturnCode.CONNECTION_ACCEPTED;</span>
						}
					}));

<span class="fc bfc" id="L129" title="All 2 branches covered.">			if (!sessionFinal.cleanSession()) {</span>
<span class="fc" id="L130">				sessionFinal.completeRemainedMessages(); // [MQTT-4.4.0-1]</span>
			}
<span class="fc" id="L132">		});</span>
<span class="fc" id="L133">	}</span>

	private void processRetainedWill(Session session) {
<span class="fc bfc" id="L136" title="All 4 branches covered.">		if (session.will() == null || !session.will().isRetain()) { return; }</span>

		// [MQTT-3.1.2-16],[MQTT-3.1.2-17]
<span class="fc" id="L139">		Topic topic = Topic.NEXUS.get(session.will().topicName());</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">		if (topic == null) {</span>
<span class="fc" id="L141">			topic = new Topic(session.will().topicName());</span>
<span class="fc" id="L142">			Topic.NEXUS.insert(topic);</span>
		}

<span class="fc" id="L145">		topic.setRetainedMessage(session.will());</span>
<span class="fc" id="L146">	}</span>

	private String generateClientId(ChannelHandlerContext ctx, boolean cleanSession) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (cleanSession) {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">			if (Settings.INSTANCE.getBoolean(&quot;mqttserver.acceptEmptyClientId&quot;, true)) {</span>
<span class="fc" id="L151">				return &quot;Lannister_&quot;</span>
<span class="fc" id="L152">						+ Long.toString(ClusterDataFactory.INSTANCE.createIdGenerator(&quot;clientIdGenerator&quot;).newId()); // [MQTT-3.1.3-6],[MQTT-3.1.3-7]</span>
			}
			else {
<span class="fc" id="L155">				sendNoneAcceptMessage(ctx, MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED);</span>
<span class="fc" id="L156">				return null;</span>
			}
		}
		else {
<span class="fc" id="L160">			sendNoneAcceptMessage(ctx, MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED); // [MQTT-3.1.3-8]</span>
<span class="fc" id="L161">			return null;</span>
		}
	}

	private Session newSession(MqttConnectMessage msg, boolean cleanSession, String clientId, String clientIp,
			int clientPort) {
<span class="fc" id="L167">		return new Session(clientId, clientIp, clientPort, msg.variableHeader().keepAliveTimeSeconds(), cleanSession,</span>
<span class="fc" id="L168">				newWill(clientId, msg));</span>
	}

	private Message newWill(String clientId, MqttConnectMessage conn) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">		if (!conn.variableHeader().isWillFlag()) { return null; } // [MQTT-3.1.2-12]</span>

<span class="fc" id="L174">		return new Message(-1, conn.payload().willTopic(), clientId,</span>
<span class="fc" id="L175">				conn.payload().willMessage().getBytes(CharsetUtil.UTF_8),</span>
<span class="fc" id="L176">				MqttQoS.valueOf(conn.variableHeader().willQos()), conn.variableHeader().isWillRetain());</span>
	}

	private boolean filterPlugins(ChannelHandlerContext ctx, MqttConnectMessage msg) {
<span class="fc" id="L180">		String clientId = msg.payload().clientIdentifier();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">		String userName = msg.variableHeader().hasUserName() ? msg.payload().userName() : null;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">		String password = msg.variableHeader().hasPassword() ? msg.payload().password() : null;</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">		if (!Plugins.INSTANCE.get(ServiceChecker.class).isServiceAvailable()) {</span>
<span class="fc" id="L185">			sendNoneAcceptMessage(ctx, MqttConnectReturnCode.CONNECTION_REFUSED_SERVER_UNAVAILABLE);</span>
<span class="fc" id="L186">			return false;</span>
		}

<span class="fc bfc" id="L189" title="All 2 branches covered.">		if (!Plugins.INSTANCE.get(Authenticator.class).isValid(clientId)) {</span>
<span class="fc" id="L190">			sendNoneAcceptMessage(ctx, MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED); // [MQTT-3.1.3-9]</span>
<span class="fc" id="L191">			return false;</span>
		}

<span class="fc bfc" id="L194" title="All 2 branches covered.">		if (!Plugins.INSTANCE.get(Authenticator.class).isValid(clientId, userName, password)) {</span>
<span class="fc" id="L195">			sendNoneAcceptMessage(ctx, MqttConnectReturnCode.CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD);</span>
<span class="fc" id="L196">			return false;</span>
		}

<span class="fc bfc" id="L199" title="All 2 branches covered.">		if (!Plugins.INSTANCE.get(Authorizer.class).isAuthorized(clientId, userName)) {</span>
<span class="fc" id="L200">			sendNoneAcceptMessage(ctx, MqttConnectReturnCode.CONNECTION_REFUSED_NOT_AUTHORIZED);</span>
<span class="fc" id="L201">			return false;</span>
		}

<span class="fc" id="L204">		return true;</span>
	}

	private void sendNoneAcceptMessage(ChannelHandlerContext ctx, MqttConnectReturnCode returnCode) {
<span class="pc bpc" id="L208" title="2 of 4 branches missed.">		assert returnCode != MqttConnectReturnCode.CONNECTION_ACCEPTED;</span>

<span class="fc" id="L210">		MqttConnAckMessage msg = MqttMessageFactory.connack(returnCode, false); // [MQTT-3.2.2-4]</span>

<span class="fc" id="L212">		ctx.channel().writeAndFlush(msg).addListener(f -&gt; {</span>
<span class="fc" id="L213">			Plugins.INSTANCE.get(ConnectEventListener.class).connectHandled(new ConnectEventArgs() {</span>
				@Override
				public String clientId() {
<span class="fc" id="L216">					return null;</span>
				}

				@Override
				public IMessage will() {
<span class="fc" id="L221">					return null;</span>
				}

				@Override
				public Boolean cleanSession() {
<span class="fc" id="L226">					return null;</span>
				}

				@Override
				public MqttConnectReturnCode returnCode() {
<span class="fc" id="L231">					return returnCode;</span>
				}
			});

<span class="fc" id="L235">			ctx.channel().disconnect().addListener(ChannelFutureListener.CLOSE).addListener(fs -&gt; // [MQTT-3.2.2-5],[MQTT-3.1.4-5]</span>
<span class="fc" id="L236">			Plugins.INSTANCE.get(DisconnectEventListener.class).disconnected(new AbnormalDisconnectEventArgs()));</span>
<span class="fc" id="L237">		});</span>
<span class="fc" id="L238">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>