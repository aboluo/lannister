<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HttpRequestHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Lannister server</a> &gt; <a href="index.source.html" class="el_package">net.anyflow.lannister.http</a> &gt; <span class="el_source">HttpRequestHandler.java</span></div><h1>HttpRequestHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 The Lannister Project
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.anyflow.lannister.http;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.net.URISyntaxException;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import org.reflections.Reflections;

import com.google.common.collect.Maps;

import net.anyflow.lannister.Settings;

<span class="fc" id="L34">public abstract class HttpRequestHandler {</span>

<span class="fc" id="L36">	private static final Map&lt;String, Class&lt;? extends HttpRequestHandler&gt;&gt; handlerClassMap = Maps.newHashMap();</span>
	private static Set&lt;Class&lt;? extends HttpRequestHandler&gt;&gt; requestHandlerClasses;
	private static String requestHandlerPakcageRoot;

	private HttpRequest request;
	private HttpResponse response;

	@Retention(RetentionPolicy.RUNTIME)
	@Target({ ElementType.TYPE, ElementType.METHOD })
	public @interface Handles {
		String[] paths();

		String[] httpMethods();

		String webResourcePath() default &quot;none&quot;;
	}

	public abstract String service();

	protected void initialize(HttpRequest request, HttpResponse response) throws URISyntaxException {
<span class="fc" id="L56">		this.request = request;</span>
<span class="fc" id="L57">		this.response = response;</span>
<span class="fc" id="L58">	}</span>

	public HttpRequest httpRequest() {
<span class="fc" id="L61">		return request;</span>
	}

	public HttpResponse httpResponse() {
<span class="nc" id="L65">		return response;</span>
	}

	public static void setRequestHandlerPakcageRoot(String requestHandlerPakcageRoot) {
<span class="fc" id="L69">		HttpRequestHandler.requestHandlerPakcageRoot = requestHandlerPakcageRoot;</span>
<span class="fc" id="L70">	}</span>

	protected static MatchedCriterion findRequestHandler(String requestedPath, String httpMethod) {
<span class="fc bfc" id="L73" title="All 2 branches covered.">		for (Map.Entry&lt;String, Class&lt;? extends HttpRequestHandler&gt;&gt; item : handlerClassMap.entrySet()) {</span>
<span class="fc" id="L74">			MatchedCriterion mc = match(requestedPath, httpMethod, item.getKey());</span>

<span class="fc bfc" id="L76" title="All 2 branches covered.">			if (mc.matched) {</span>
<span class="fc" id="L77">				mc.requestHandlerClass = handlerClassMap.get(item.getKey());</span>
<span class="fc" id="L78">				return mc;</span>
			}
<span class="fc" id="L80">		}</span>

<span class="fc bfc" id="L82" title="All 2 branches covered.">		if (requestHandlerClasses == null) {</span>
<span class="fc" id="L83">			requestHandlerClasses = new Reflections(requestHandlerPakcageRoot).getSubTypesOf(HttpRequestHandler.class);</span>
		}

<span class="fc" id="L86">		final ReturnWrapper wrapper = new ReturnWrapper();</span>
<span class="fc" id="L87">		requestHandlerClasses.stream().anyMatch(c -&gt; {</span>
<span class="fc" id="L88">			HttpRequestHandler.Handles annotation = c.getAnnotation(HttpRequestHandler.Handles.class);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">			if (annotation == null) { return false; }</span>

<span class="fc" id="L91">			return Stream.of(annotation.httpMethods()).anyMatch(m -&gt; {</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">				if (!m.equalsIgnoreCase(httpMethod)) { return false; }</span>

<span class="fc" id="L94">				return Stream.of(annotation.paths()).anyMatch(p -&gt; {</span>
<span class="fc" id="L95">					return wrapper.setValueIfMatch(requestedPath, c, m, p);</span>
				});
			});
		});

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">		return wrapper.value == null ? new MatchedCriterion() : wrapper.value;</span>
	}

<span class="fc" id="L103">	private static class ReturnWrapper {</span>
<span class="fc" id="L104">		private MatchedCriterion value = null;</span>

		private boolean setValueIfMatch(String requestedPath, Class&lt;? extends HttpRequestHandler&gt; handlerClass,
				String methodToCheck, String pathToCheck) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">			String path = (pathToCheck.charAt(0) == '/') ? pathToCheck</span>
<span class="fc" id="L109">					: Settings.INSTANCE.httpContextRoot() + pathToCheck;</span>
<span class="fc" id="L110">			String criterion = path + &quot;/&quot; + methodToCheck;</span>

<span class="fc" id="L112">			MatchedCriterion mc = match(requestedPath, methodToCheck, criterion);</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (mc.matched) {</span>
<span class="fc" id="L115">				handlerClassMap.put(criterion, handlerClass);</span>
<span class="fc" id="L116">				mc.requestHandlerClass = handlerClass;</span>
<span class="fc" id="L117">				this.value = mc;</span>

<span class="fc" id="L119">				return true;</span>
			}
			else {
<span class="fc" id="L122">				return false;</span>
			}
		};
	}

<span class="fc" id="L127">	protected static class MatchedCriterion {</span>
<span class="fc" id="L128">		private boolean matched = false;</span>
		private Class&lt;? extends HttpRequestHandler&gt; requestHandlerClass;
		private String criterionPath;
		private String criterionHttpMethod;
<span class="fc" id="L132">		private final Map&lt;String, String&gt; pathParameters = Maps.newHashMap();</span>

		public Class&lt;? extends HttpRequestHandler&gt; requestHandlerClass() {
<span class="fc" id="L135">			return requestHandlerClass;</span>
		}

		public String criterionPath() {
<span class="nc" id="L139">			return criterionPath;</span>
		}

		public String criterionHttpMethod() {
<span class="nc" id="L143">			return criterionHttpMethod;</span>
		}

		public Map&lt;String, String&gt; pathParameters() {
<span class="fc" id="L147">			return pathParameters;</span>
		}
	}

	private static MatchedCriterion match(String requestedPath, String httpMethod, String criterion) {
<span class="fc" id="L152">		MatchedCriterion ret = new MatchedCriterion();</span>

<span class="fc" id="L154">		String testTarget = requestedPath + &quot;/&quot; + httpMethod;</span>

<span class="fc" id="L156">		String[] testTokens = testTarget.split(&quot;/&quot;);</span>
<span class="fc" id="L157">		String[] criterionTokens = criterion.split(&quot;/&quot;);</span>

<span class="pc bpc" id="L159" title="1 of 2 branches missed.">		if (criterionTokens.length != testTokens.length) { return ret; }</span>

		// should start with #1 due to item[0] is whitespace.
<span class="fc bfc" id="L162" title="All 2 branches covered.">		for (int i = 1; i &lt; criterionTokens.length; ++i) {</span>
<span class="pc bpc" id="L163" title="3 of 4 branches missed.">			if (criterionTokens[i].startsWith(&quot;{&quot;) &amp;&amp; criterionTokens[i].endsWith(&quot;}&quot;)) {</span>
<span class="nc" id="L164">				ret.pathParameters.put(criterionTokens[i].substring(1, criterionTokens[i].length() - 1), testTokens[i]);</span>
			}
<span class="fc bfc" id="L166" title="All 2 branches covered.">			else if (!criterionTokens[i].equalsIgnoreCase(testTokens[i])) { return ret; }</span>
		}

<span class="fc" id="L169">		ret.matched = true;</span>
<span class="fc" id="L170">		ret.criterionHttpMethod = httpMethod;</span>
<span class="fc" id="L171">		ret.criterionPath = criterion.replace(&quot;/&quot; + httpMethod, &quot;&quot;);</span>

<span class="fc" id="L173">		return ret;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>